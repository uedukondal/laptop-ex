# -*- coding: utf-8 -*-
"""final print

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18GllfJLJv6lYasxx0QLNDsv4OdIyc__m
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import r2_score,mean_absolute_error
from sklearn.linear_model import LinearRegression,Ridge,Lasso
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor,GradientBoostingRegressor,AdaBoostRegressor,ExtraTreesRegressor
from sklearn.svm import SVR
from xgboost import XGBRegressor

df = pd.read_csv("Gathered_data.csv")
df

df['operating_system'].replace(0,1,inplace = True)
df['operating_system'].value_counts()

sns.distplot(df['price(in rupees)'])

df['brand'].value_counts().plot(kind='bar')

sns.barplot(x=df['brand'],y=df['price(in rupees)'])
plt.xticks(rotation='vertical')
plt.show()

sns.distplot(df['screen_size'])

sns.scatterplot(x=df['screen_size'],y=df['price(in rupees)'])

sns.barplot(x=df['operating_system'],y=df['price(in rupees)'])
plt.xticks(rotation='vertical')
plt.show()

df['touchscreen'].value_counts().plot(kind='bar')

sns.barplot(x=df['touchscreen'],y=df['price(in rupees)'])

X = df.drop(columns=['price(in rupees)','gpu_brand','cpu_model'])
y = np.array(df['price(in rupees)'])

X

y

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.15,random_state=2)

X_train

X_test

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(drop='first'),[0,1])
],remainder='passthrough')

step2 = LinearRegression()

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(drop='first'),[0,1])
],remainder='passthrough')

step2 = Ridge(alpha=10)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(drop='first'),[0,1])
],remainder='passthrough')

step2 = Lasso(alpha=0.001)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(drop='first'),[0,1])
],remainder='passthrough')

step2 = KNeighborsRegressor(n_neighbors=3)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(drop='first'),[0,1])
],remainder='passthrough')

step2 = DecisionTreeRegressor(max_depth=8)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(drop='first'),[0,1])
],remainder='passthrough')

step2 = RandomForestRegressor(n_estimators=100,
                              random_state=3,
                              max_samples=0.5,
                              max_features=0.75,
                              max_depth=15)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(drop='first'),[0,1])
],remainder='passthrough')

step2 = ExtraTreesRegressor(n_estimators=100,
                              random_state=3,
                              max_features=0.75,
                              max_depth=15)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

brand = "HP"
cpuBrand = "Intel"
cpuGeneration = 11
cpuCores = 6
cpuThreads = 12
ram = 8
storage = 256
ssd = 1
hdd = 0
graphicVram = 0
battery = 70
operatingSystem = 1
screenSize = 15.6
ppi = 200
touchscreen = 0

yd = np.array([[
brand, cpuBrand, cpuGeneration, cpuCores, cpuThreads, ram, storage, ssd, hdd, graphicVram, battery, operatingSystem, screenSize, ppi, touchscreen
]])
prediction = pipe.predict(yd)

predicted_price = prediction[0]  # Access the first (and only) element in the array
print(f'The Predicted price with your specifications: {predicted_price}')

def find_ranges(num):
    str_num = str(num)
    first_digit = int(str_num[0])
    length = len(str_num)

    # Calculate the lowest range
    lowest_range = first_digit * (10 ** (length + 1))

    # Calculate the highest range
    highest_range = (first_digit + 1) * (10 ** (length - 1))

    return lowest_range, highest_range

laptop = pd.read_csv("sample_laptop.csv")
laptop

min_price = int(input("Enter the minimum price: "))
max_price = int(input("Enter the maximum price: "))
brand = input("Enter the laptop brand (or leave blank for all): ").strip().lower()
filtered_laptops = laptop[laptop['Price'].between(min_price, max_price)]
if brand:
    filtered_laptops = filtered_laptops[filtered_laptops['Company'].str.lower() == brand]
def format_laptops_multiline(df):
    if df.empty:
        return "No laptops found."
    return '\n'.join(df.apply(
        lambda x: f"Brand: {x['Company']}, Type: {x['TypeName']}, Price: ₹{x['Price']}, CPU: {x['Cpu']}, RAM: {x['Ram']}, Storage: {x['Memory']}",
        axis=1))

print("\nLaptops in Selected Price Range:")
print(format_laptops_multiline(filtered_laptops))

predicted_price = int(input("Enter the predicted price: "))
brand = input("Enter the laptop brand: ")
def find_ranges(price):
    return price - 5000, price + 5000
low, high = find_ranges(predicted_price)
main_range = laptop[laptop['Price'].between(low, high)]
budget_range = laptop[laptop['Price'].between(35000, 45000)]
premium_range = laptop[laptop['Price'] > 100000]
main_range = main_range[main_range['Company'].str.lower() == brand.lower()]
budget_range = budget_range[budget_range['Company'].str.lower() == brand.lower()]
premium_range = premium_range[premium_range['Company'].str.lower() == brand.lower()]

def format_laptops_multiline(df):
    if df.empty:
        return "No laptops found."
    return '\n'.join(df.apply(
        lambda x: f"Brand: {x['Company']}, Type: {x['TypeName']}, Price: ₹{x['Price']}, CPU: {x['Cpu']}, RAM: {x['Ram']}, Storage: {x['Memory']}",
        axis=1))



print(" Laptops in Predicted Price Range:")
print(format_laptops_multiline(main_range), '\n')

low , high = find_ranges(int(predicted_price))
print(low ," " ,high)

result = laptop[laptop['Price'].between(low, high)]

result[result["Company"] == brand]

import pickle

pickle.dump(df,open('df.pkl','wb'))
pickle.dump(pipe,open('pipe.pkl','wb'))